var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { toSafeString, trimNumber, validateNumber } from './utils';
var Decimal = /** @class */ (function () {
    function Decimal(value) {
        this.origin = '';
        this.origin = String(value);
        if ((!value && value !== 0) || !this.origin.trim()) {
            this.isEmpty = true;
            return;
        }
        if (value === '-') {
            this.isNaN = true;
            return;
        }
        var safeValueString = toSafeString(value);
        if (validateNumber(safeValueString)) {
            var _a = trimNumber(safeValueString), negative = _a.negative, trimStr = _a.trimStr;
            var _b = __read(trimStr.split('.'), 2), integerStr = _b[0], _c = _b[1], decimalStr = _c === void 0 ? '0' : _c;
            this.isNegative = negative;
            this.integer = BigInt(integerStr);
            this.decimal = BigInt(decimalStr);
            this.decimalLen = decimalStr.length;
        }
        else {
            this.isNaN = true;
        }
    }
    Decimal.from = function (value) {
        return new Decimal(value);
    };
    Object.defineProperty(Decimal.prototype, "isInvalid", {
        get: function () {
            return this.isEmpty || this.isNaN;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Decimal.prototype, "mark", {
        get: function () {
            return this.isNegative ? '-' : '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Decimal.prototype, "integerStr", {
        get: function () {
            return this.integer.toString();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Decimal.prototype, "decimalStr", {
        get: function () {
            return this.decimal.toString().padStart(this.decimalLen, '0');
        },
        enumerable: false,
        configurable: true
    });
    Decimal.prototype.alignDecimal = function (decimalLength) {
        return BigInt("" + this.mark + this.integerStr + this.decimalStr.padEnd(decimalLength, '0'));
    };
    Decimal.prototype.negate = function () {
        var clone = new Decimal(this.toString());
        clone.isNegative = !clone.isNegative;
        return clone;
    };
    Decimal.prototype.add = function (value) {
        var offset = new Decimal(value);
        if (offset.isInvalid) {
            return this;
        }
        if (this.isInvalid) {
            return offset;
        }
        var maxDecimalLength = Math.max(this.decimalLen, offset.decimalLen);
        var thisAlignedDecimal = this.alignDecimal(maxDecimalLength);
        var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);
        var valueStr = (thisAlignedDecimal + offsetAlignedDecimal).toString();
        var _a = trimNumber(valueStr), negativeStr = _a.negativeStr, trimStr = _a.trimStr;
        var hydrateValueStr = "" + negativeStr + trimStr.padStart(maxDecimalLength + 1, '0');
        return new Decimal(hydrateValueStr.slice(0, -maxDecimalLength) + "." + hydrateValueStr.slice(-maxDecimalLength));
    };
    Decimal.prototype.equals = function (target) {
        return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    };
    Decimal.prototype.less = function (target) {
        return this.isInvalid || target.isInvalid
            ? false
            : this.add(target.negate().toString()).toNumber() < 0;
    };
    Decimal.prototype.toNumber = function () {
        return this.isNaN ? NaN : Number(this.toString());
    };
    Decimal.prototype.toString = function (options) {
        if (options === void 0) { options = { safe: true }; }
        var safe = options.safe, precision = options.precision;
        var result = safe
            ? this.isInvalid
                ? ''
                : trimNumber("" + this.mark + this.integerStr + "." + this.decimalStr).fullStr
            : this.origin;
        return typeof precision === 'number' ? Decimal.toFixed(result, precision) : result;
    };
    /**
     * Replace String.prototype.toFixed like Math.round
     * If cutOnly is true, just slice the tail
     * e.g. Decimal.toFixed(0.15) will return 0.2, not 0.1
     */
    Decimal.toFixed = function (numStr, precision, cutOnly) {
        if (cutOnly === void 0) { cutOnly = false; }
        if (numStr === '') {
            return '';
        }
        var separator = '.';
        var _a = trimNumber(numStr), negativeStr = _a.negativeStr, integerStr = _a.integerStr, decimalStr = _a.decimalStr;
        var precisionDecimalStr = "" + separator + decimalStr;
        var numberWithoutDecimal = "" + negativeStr + integerStr;
        if (precision >= 0) {
            var advancedNum = Number(decimalStr[precision]);
            if (advancedNum >= 5 && !cutOnly) {
                var advancedDecimal = Decimal.from(numStr).add(negativeStr + "0." + '0'.repeat(precision) + (10 - advancedNum));
                return Decimal.toFixed(advancedDecimal.toString(), precision, cutOnly);
            }
            return precision === 0
                ? numberWithoutDecimal
                : "" + numberWithoutDecimal + separator + decimalStr
                    .padEnd(precision, '0')
                    .slice(0, precision);
        }
        return "" + numberWithoutDecimal + (precisionDecimalStr === '.0' ? '' : precisionDecimalStr);
    };
    return Decimal;
}());
export { Decimal };
